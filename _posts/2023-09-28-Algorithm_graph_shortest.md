---
layout: post
title:  "Shortest-Path"
date:   2023-09-28
author: Easyfun
categories: Alorithm
cover:  "/assets/cover-thumb.png"
tags: [documentation,sample]
image: Rustacean.png
---

## åœ–å½¢æœ€çŸ­è·¯å¾‘æ³•

æœ€çŸ­è·¯å¾‘æ˜¯åœ–å½¢çš„ç¶“å…¸æ¼”ç®—æ³•ï¼Œåœ¨ä¸€å€‹æœ‰åƒåœ–å½¢G=(V,E)ä¸­ï¼ŒGæ¯ä¸€å€‹é‚Šéƒ½æœ‰ä¸€å€‹æ¯”ä¾‹å¸¸æ•¸Wèˆ‡ä¹‹å°æ‡‰ï¼Œæƒ³è¦æ±‚Gåœ–å½¢ä¸­æŸä¸€å€‹é ‚é»V0åˆ°å…¶ä»–é ‚é»çš„æœ€å°‘ç¸½å’Œä¹‹å€¼ï¼Œé€™å°±ç¨±ç‚ºæœ€çŸ­è·¯å¾‘æ³•ã€‚

æ¥ä¸‹ä¾†ä»‹ç´¹æœ€çŸ­è·¯å¾‘çš„å¸¸è¦‹æ¼”ç®—æ³•ã€‚

### Dijkstra's algorithm

Dijkstraæ¼”ç®—æ³•å¯ä»¥æ‰¾åˆ°åœ–ä¸­æœ€çŸ­è·¯å¾‘ï¼Œä¹Ÿå¯ä»¥æ‰¾åˆ°å¾ç¯€é»åˆ°åœ–ä¸­æ‰€æœ‰å…¶ä»–ç¯€é»çš„æœ€çŸ­è·¯å¾‘ã€‚é‚„å¯ä»¥è¿½è¹¤ç›®å‰å·²çŸ¥çš„å¾æ¯å€‹ç¯€é»ä¹‹é–“çš„æœ€çŸ­è·¯å¾‘ï¼Œå¦‚æœç™¼ç¾æ›´çŸ­çš„è·¯å¾‘ï¼Œå‰‡æœƒæ›´æ–°é€™äº›å€¼ã€‚

ä¸€æ—¦æ¼”ç®—æ³•æ‰¾åˆ°ä¾†æºç¯€é»å’Œå¦ä¸€å€‹ç¯€é»ä¹‹é–“çš„æœ€çŸ­è·¯å¾‘ï¼Œè©²ç¯€é»æœƒè¢«æ¨™è¨˜ç‚ºã€Œå·²å­˜å–ã€ä¸¦æ·»åŠ åˆ°è·¯å¾‘ä¸­ï¼Œè©²éç¨‹æŒçºŒé€²è¡Œï¼Œç›´åˆ°åœ–ä¸­çš„æ‰€æœ‰ç¯€é»éƒ½ä»¥æ–°å¢è‡³è·¯å¾‘ä¸­ï¼Œé€™æ¨£å°±æœ‰ä¸€æ¢ä¾†æºç¯€é»é€£æ¥åˆ°æ‰€æœ‰å…¶ä»–ç¯€é»çš„è·¯å¾‘ï¼Œè©²è·¯å¾‘éµå¾ªå¯èƒ½åˆ°é”æ¯å€‹ç¯€é»çš„æœ€çŸ­è·¯å¾‘ã€‚

Dijkstra'sæ¼”ç®—æ³•:

    å‡è¨­S={Vi|Vi âˆˆ V}ï¼Œä¸”Viæ˜¯å·²ç™¼ç¾çš„æœ€çŸ­è·¯å¾‘ï¼Œå…¶ä¸­V_0 âˆˆ Sæ˜¯èµ·é»ã€‚

å‡è¨­Wâˆ‰Sï¼Œå®šç¾©Dist(w)æ˜¯å¾V_0åˆ°wçš„æœ€çŸ­è·¯å¾‘ï¼Œé™¤äº†wå¤–å¿…å±¬æ–¼Sã€‚

â“µ å¦‚æœuæ˜¯ç›®å‰æ‰€æ‰¾åˆ°æœ€çŸ­è·¯å¾‘ä¹‹ä¸‹ä¸€å€‹ç¯€é»ï¼Œå‰‡å¿…å±¬æ–¼V-Sé›†åˆä¸­æœ€å°èŠ±è²»æˆæœ¬çš„é‚Šã€‚

â“¶ è‹¥uè¢«é¸ä¸­ï¼Œå°‡uåŠ å…¥Sé›†åˆä¸­å‰‡æœƒç”¢ç”Ÿç›®å‰V_0åˆ°uæœ€çŸ­è·¯å¾‘ï¼Œå°æ–¼Wâˆ‰Sï¼ŒDIST(w)æ”¹è®ŠæˆDIST(w) â† Min{DIST(w),DIST(u) + COST(u,w)}

å¾ä»¥ä¸Šæ¨æ¼”å‡ºæ¼”ç®—æ³•æ­¥é©Ÿ:

â’¶ 

    G=(V,E)
    D[k]=A[F,K]ï¼Œkå¾1åˆ°N
    S={F}
    V={1,2,...N}

Dç‚ºä¸€å€‹Nç¶­é™£åˆ—ç”¨ä¾†å­˜æ”¾æŸä¸€é ‚é»åˆ°å…¶ä»–é ‚é»æœ€çŸ­è·é›¢

Fè¡¨ç¤ºèµ·å§‹é ‚é»

A[F,I]ç‚ºé ‚é»Fåˆ°Içš„è·é›¢

Væ˜¯ç¶²è·¯ä¸­æ‰€æœ‰é ‚é»çš„é›†åˆ

Eæ˜¯ç¶²è·¯ä¸­æ‰€æœ‰é‚Šçš„çµ„åˆ

Sæ˜¯é ‚é»çš„é›†åˆï¼Œåˆå§‹å€¼æ˜¯A={F}


â’· å¾V-Sé›†åˆä¸­æ‰¾åˆ°ä¸€å€‹é ‚é»xï¼Œä½¿D(x)çš„å€¼ç‚ºæœ€å°å€¼ï¼Œä¸¦æŠŠxæ”¾å…¥Sé›†åˆä¸­ã€‚

â’¸ ä¾å…¬å¼

D[I]=min(D[i],D[x]+A[x,I])åŸ·è¡Œï¼Œå…¶ä¸­(x,I)âˆˆ Eä¾†èª¿æ•´Dé™£åˆ—çš„å€¼ï¼Œå…¶ä¸­Iæ˜¯æŒ‡xçš„ç›¸é„°å€‹é ‚é»ã€‚

â’¹ é‡è¤‡åŸ·è¡Œæ­¥é©ŸBï¼Œä¸€ç›´åˆ°V-Sæ˜¯ç©ºé›†åˆç‚ºæ­¢ã€‚

ä»¥ä¸‹åœ–ç‚ºä¾‹ï¼Œé ‚é»5åˆ°å„é …é ‚é»é–“çš„æœ€çŸ­è·¯å¾‘ã€‚

![alt text]({{ site.baseurl }}/assets/img/DIJ.jpg "Profile Picture"){:.profile}

åšæ³•æ˜¯ç”±é ‚é»5é–‹å§‹ï¼Œæ‰¾å‡ºé ‚é»5åˆ°å„é …é ‚é»é–“æœ€å°çš„è·é›¢ï¼Œåˆ°é”ä¸äº†ä»¥âˆè¡¨ç¤ºã€‚

ä»–çš„æ­¥é©Ÿç‚º:

ğŸ…° D[0]=âˆ,D[1]=12,D[2]=âˆ,D[3]=20,D[4]=14ã€‚å…¶ä¸­æ‰¾å‡ºæœ€å°çš„é ‚é»ï¼ŒåŠ å…¥Sé›†åˆä¸­:D[1]ã€‚

ğŸ…± D[0]=âˆ,D[1]=12,D[2]=18,D[3]=20,D[4]=14ã€‚D[4]æœ€å°ï¼ŒåŠ å…¥Sé›†åˆä¸­ã€‚

ğŸ…² D[0]=26,D[1]=12,D[2]=18,D[3]=20,D[4]=14ã€‚D[2]æœ€å°ï¼ŒåŠ å…¥Sé›†åˆä¸­ã€‚

ğŸ…³ D[0]=26,D[1]=12,D[2]=18,D[3]=20,D[4]=14ã€‚D[3]æœ€å°ï¼ŒåŠ å…¥Sé›†åˆä¸­ã€‚

ğŸ…´ åŠ å…¥æœ€å¾Œä¸€å€‹é ‚é»å³å¯å¾—åˆ°:

| æ­¥é©Ÿ | S | 0 | 1 | 2 | 3 | 4 | 5 | é¸æ“‡ |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | 5 | âˆ | 12 | âˆ | 20 | 14 | 0 | 1 |
| 2 | 5,1 | âˆ | 12 | 18 | 20 | 14 | 0 | 4 |
| 3 | 5,1,4 | 26 | 12 | 18 | 20 | 14 | 0 | 2 |
| 4 | 5,1,4,2 | 26 | 12 | 18 | 20 | 14 | 0 | 3 |
| 5 | 5,1,4,2,3 | 26 | 12 | 18 | 20 | 14 | 0 | 0 |

ç”±é ‚é»5åˆ°å…¶ä»–å„é …é ‚é»çš„æœ€çŸ­è·é›¢:

é ‚é»5 â€’  é ‚é»0:26

é ‚é»5 â€’  é ‚é»1:12

é ‚é»5 â€’  é ‚é»2:18

é ‚é»5 â€’  é ‚é»3:20

é ‚é»5 â€’  é ‚é»4:14

Dijkstra'sæ¼”ç®—æ³•:

{% highlight rust %}

  fn dijkstra(&self, start: usize) -> HashMap<usize, usize> {
        let mut distances = HashMap::new();
        let mut visited = HashSet::new();
        let mut min_heap = BinaryHeap::new(); // Min-heap for nodes

        distances.insert(start, 0);
        min_heap.push(Node {
            id: start,
            distance: 0,
        });

        while let Some(Node { id, distance }) = min_heap.pop() {
            if !visited.contains(&id) {
                visited.insert(id);

                for &Edge { to, weight } in self.adjacency_list.get(&id).unwrap_or(&Vec::new()) {
                    let new_distance = distance + weight;
                    let current_distance = *distances.get(&to).unwrap_or(&usize::MAX);

                    if new_distance < current_distance {
                        distances.insert(to, new_distance);
                        min_heap.push(Node { id: to, distance: new_distance });
                    }
                }
            }
        }

        distances
    }
}

{% endhighlight %}

åˆ©ç”¨æœ€å°å †å’Œ HashMap ä¾†å¯¦ç¾ Dijkstra's Algorithmï¼Œä¸¦æ‰¾åˆ°å¾ç‰¹å®šèµ·é»åˆ°æ‰€æœ‰å…¶ä»–ç¯€é»çš„æœ€çŸ­è·¯å¾‘ã€‚


### A * 's algorithm

Dijkstra'sæ¼”ç®—æ³•æ˜¯å°‹æ‰¾æœ€çŸ­è·¯å¾‘çš„éç¨‹ä¸­ç®—æ˜¯è¼ƒä¸å…·æ•ˆç‡çš„åšæ³•ï¼Œæ˜¯å› ç‚ºé€™å€‹æ¼”ç®—æ³•åœ¨å°‹æ‰¾èµ·é»åˆ°å€‹é ‚é»è·é›¢çš„éç¨‹ä¸­ï¼Œä¸è«–å“ªä¸€å€‹é ‚é»ï¼Œéƒ½è¦å¯¦éš›å»è¨ˆç®—èµ·é»èˆ‡å€‹é ‚é»é–“çš„è·é›¢ï¼Œä¾†å–å¾—æœ€å¾Œä¸€å€‹åˆ¤æ–·ï¼Œåˆ°åº•å“ªä¸€å€‹é ‚é»è·é›¢èˆ‡èµ·é»æœ€è¿‘ã€‚

åœ¨éœ€æ±‚çš„è€ƒé‡ä¸‹ï¼ŒA * æ¼”ç®—æ³•å¯ä»¥èªªæ˜¯Dijkstra'sæ¼”ç®—æ³•çš„æ”¹è‰¯ï¼Œçµåˆäº†åœ¨è·¯å¾‘æœå°‹éç¨‹ä¸­ï¼Œå¾èµ·é»åˆ°å„é …é ‚é»çš„ã€Œå¯¦éš›æ¬Šé‡ã€ï¼ŒåŠå€‹é ‚é»é ä¼°åˆ°æ‰“ä¸­é»çš„ã€Œæ¨æ¸¬æ¬Šé‡ã€å…©é …ï¼Œé€™å¯ä»¥æœ‰æ•ˆæ¸›å°‘ä¸å¿…è¦çš„æœå°‹å‹•ä½œï¼Œä»¥æé«˜æœå°‹æœ€çŸ­è·¯å¾‘çš„æ•ˆç‡ã€‚

A * æ¼”ç®—æ³•ä¹Ÿæ˜¯æœ€çŸ­è·¯å¾‘æ¼”ç®—æ³•ï¼Œæœƒé å…ˆè¨­å®šä¸€å€‹ã€Œæ¨æ¸¬æ¬Šé‡ã€ä¸€ä½µç´å…¥æ±ºå®šæœ€çŸ­è·¯å¾‘çš„è€ƒæ…®å› ç´ ã€‚æ¨æ¸¬æ¬Šé‡æ˜¯äº‹å…ˆçŸ¥é“çš„è³‡è¨Šä¾†çµ¦å®šä¸€å€‹é ä¼°å€¼ï¼Œçµåˆé€™å€‹é ä¼°å€¼ï¼Œå¯ä»¥æ›´æœ‰æ•ˆç‡æœå°‹æœ€çŸ­è·¯å¾‘ã€‚

A * æ¼”ç®—æ³•ä¸åƒDijkstra'sæ¼”ç®—æ³•åªè€ƒæ…®èµ·é»åˆ°é€™å€‹é ‚é»çš„å¯¦éš›æ¬Šé‡ä¾†æ±ºå®šä¸‹ä¸€æ­¥è¦å˜—è©¦çš„é ‚é»ï¼Œä¸åŒçš„åšæ³•æ˜¯ï¼ŒA * æ¼”ç®—æ³•åœ¨è¨ˆç®—å¾èµ·é»åˆ°å€‹é ‚é»çš„æ¬Šé‡ï¼ŒæœƒåŒæ­¥è€ƒæ…®å¾èµ·é»åˆ°é€™å€‹é ‚é»çš„å¯¦éš›æ¬Šé‡ï¼Œå†åŠ ä¸Šè©²é ‚é»åˆ°çµ‚é»çš„æ¨æ¸¬æ¬Šé‡ï¼Œä»¥æ¨ä¼°å‡ºè©²é ‚é»å¾èµ·é»åˆ°çµ‚é»çš„æ¬Šé‡ã€‚å†å¾å…¶ä¸­é¸å‡ºä¸€å€‹æ¬Šé‡æœ€å°çš„é ‚é»ï¼Œä¸¦å°‡è©²é ‚é»æ¨™ç¤ºç‚ºä»¥æœå°‹å®Œç•¢ã€‚æ¥è‘—å†è¨ˆç®—å¾æœå°‹å®Œç•¢çš„é»å‡ºç™¼åˆ°å„é ‚é»çš„æ¬Šé‡ï¼Œä¸¦å†å¾å…¶ä¸­é¸å‡ºä¸€å€‹æ¬Šé‡æœ€å°çš„é»ï¼Œä¾åºå‰é¢çš„åšæ³•ï¼Œä¸¦å°‡è©²é ‚é»æ¨™ç¤ºç‚ºå·²æœå°‹å®Œç•¢çš„é ‚é»ï¼Œä»¥æ­¤é¡æ¨ï¼Œåè¦†é€²è¡Œä¸€ç›´åˆ°æŠµé”çµ‚é»ï¼Œæ‰çµæŸæœå°‹å·¥ä½œä»¥å¾—åˆ°æœ€çŸ­è·¯å¾‘çš„æœ€ä½³è§£ã€‚

é€™è½èµ·ä¾†æŒºè¤‡é›œçš„ï¼Œä¾†åšA * æ¼”ç®—æ³•æ­¥é©Ÿ:

ğ˜ˆ é¦–å…ˆæ±ºå®šå„é …é ‚é»åˆ°çµ‚é»çš„ã€Œæ¨æ¸¬æ¬Šé‡ã€ã€‚ã€Œæ¨æ¸¬æ¬Šé‡ã€çš„è¨ˆç®—æ–¹å¼å¯ä»¥æ¡ç”¨å„é ‚é»å’Œçµ‚é»é–“çš„ç›´ç·šè·é›¢ï¼Œæ¡ç”¨å››æ¨äº”å…¥å¾Œçš„å€¼ï¼Œç›´ç·šè·é›¢çš„è¨ˆç®—å‡½æ•¸ï¼Œå¾é€™å¹¾ç¨®è©•ä¼°å‡½æ•¸çš„è¨ˆç®—æ–¹å¼ã€‚

ğ˜‰ åˆ†åˆ¥è¨ˆç®—å¾èµ·é»å¯æŠµé”çš„å„å€‹é ‚é»çš„æ¬Šé‡ï¼Œè¨ˆç®—æ–¹å¼æ˜¯ç”±èµ·é»åˆ°è©²é ‚é»çš„ã€Œå¯¦éš›æ¬Šé‡ã€ï¼ŒåŠ ä¸Šè©²é ‚é»æŠµé”çµ‚é»çš„ã€Œæ¨æ¸¬æ¬Šé‡ã€ï¼Œè¨ˆç®—å®Œç•¢å¾Œé¸å‡ºæ¬Šé‡æœ€å°çš„é»ï¼Œä¸¦æ¨™ç¤ºç‚ºæœå°‹å®Œç•¢çš„é»ã€‚

ğ˜Š æ¥è‘—è¨ˆç®—å¾æœå°‹å®Œç•¢çš„é»å‡ºç™¼åˆ°å€‹é»çš„æ¬Šé‡ï¼Œä¸¦å†å¾å…¶ä¸­é¸å‡ºä¸€å€‹æ¬Šé‡æœ€å°çš„é»ï¼Œä¸¦å°‡å…¶æ¨™ç¤ºç‚ºæœå°‹å®Œç•¢çš„é»ã€‚ä»¥æ¬¡é¡æ¨ï¼Œåè¦†é€²è¡ŒåŒæ¨£çš„è¨ˆç®—éç¨‹ï¼Œä¸€ç›´åˆ°æŠµé”çµ‚é»ã€‚

A * æ¼”ç®—æ³•é©ç”¨æ–¼å¯ä»¥äº‹å…ˆç²å¾—æˆ–é ä¼°å„é …é ‚é»åˆ°çµ‚é»è·é›¢çš„æƒ…æ³ï¼Œä½†æ˜¯ç„¡æ³•å–å¾—å„é …é ‚é»åˆ°ç›®çš„åœ°çµ‚é»çš„è·é›¢è³‡è¨Šæ™‚ï¼Œå°±ç„¡æ³•ä½¿ç”¨A * æ¼”ç®—æ³•ã€‚ä¹Ÿä¸æ˜¯ä»»ä½•æƒ…æ³ä¸‹A * æ¼”ç®—æ³•æ•ˆç‡ä¸€å®šå„ªæ–¼Dijkstra'sæ¼”ç®—æ³•ã€‚ä¾‹å¦‚:ç•¶ã€Œæ¨æ¸¬æ¬Šé‡ã€çš„è·é›¢å’Œå¯¦éš›å…©å€‹é ‚é»é–“çš„è·é›¢ç›¸å·®ç”šå¤§æ™‚ï¼ŒA * æ¼”ç®—æ³•çš„æœå°‹æ•ˆç‡å¯èƒ½å°±æ¯”Dijkstra'sæ¼”ç®—æ³•å·®ï¼Œç”šè‡³é‚„æœƒèª¤å°æ–¹å‘ï¼Œé€ æˆç„¡æ³•å¾—åˆ°æœ€çŸ­è·¯å¾‘çš„ç­”æ¡ˆã€‚


{% highlight rust %}

fn astar(&self, start: usize, goal: usize) -> Option<Vec<usize>> {
        let mut costs = HashMap::new();
        let mut visited = HashMap::new();
        let mut min_heap = BinaryHeap::new(); // Min-heap for nodes

        costs.insert(start, 0);
        min_heap.push(Node {
            id: start,
            cost: 0,
            heuristic: 0,
        });

        // ä¸æ–·å¾æœ€å°å †ç©ä¸­å–å‡ºç¯€é»ï¼Œç›´åˆ°å †ç©ç‚ºç©º
        while let Some(Node { id, cost, heuristic }) = min_heap.pop() {

            if id == goal {
                // æª¢æŸ¥ç•¶å‰å–å‡ºçš„ç¯€é»æ˜¯å¦æ˜¯ç›®æ¨™ç¯€é»ã€‚å¦‚æœæ˜¯ï¼Œå‰‡é‡å»ºè·¯å¾‘ï¼Œè¿”å›æœ€çŸ­è·¯å¾‘
                let mut path = vec![goal];
                let mut current = id;
                while let Some(&prev) = visited.get(&current) {
                    path.push(prev);
                    current = prev;
                }
                path.reverse();
                return Some(path);
            }

            for &Edge { to, weight } in self.adjacency_list.get(&id).unwrap_or(&Vec::new()) {
                let new_cost = cost + weight;
                let current_cost = *costs.get(&to).unwrap_or(&usize::MAX);

                if new_cost < current_cost {
                    let heuristic = self.heuristic(to, goal);
                    let priority = new_cost + heuristic;

                    costs.insert(to, new_cost);
                    // åˆå§‹åŒ–èµ·é»çš„å¯¦éš›ä»£åƒ¹ç‚º 0
                    visited.insert(to, id);
                    min_heap.push(Node {
                        id: to,
                        cost: new_cost,
                        heuristic,
                    });
                }
            }
        }

        None // No path found
    }

{% endhighlight %}


